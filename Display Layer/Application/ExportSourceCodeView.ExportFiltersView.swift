//
//  ExportFiltersView.swift
//  Hippocampus
//
//  Created by Guido Kühn on 20.07.24.
//

import Grisu
import SwiftUI

extension ExportSourceCodeView {
    struct ExportFiltersView: View {
        // MARK: Properties

        @Environment(\.document) var document
        @State var fileUrl: URL?
        @State var selectedFilters: [Structure.Filter] = []
        @State var importFile = false
        @State var showExportConfirmation = false
        @State var showDeleteConfirmation = false

        let formatter: DateFormatter = {
            let formatter = DateFormatter()
            formatter.dateFormat = "dd.MM.yyyy HH:mm"
            return formatter
        }()

        // MARK: Computed Properties

        var filters: [Structure.Filter] {
            document.structure.filters
                .sorted(by: { $0.description < $1.description })
        }

        var filtersSourceCode: String {
            var result = """
            //
            //  \(fileUrl?.lastPathComponent ?? "No file selected")
            //  Hippocampus
            //
            //  Created by Guido Kühn on 19.06.24.
            //  Generated by Hippocampus on \(formatter.string(from: Date())).
            //

            import Foundation
            import SwiftUI
            import Grisu

            extension Structure.Filter {
            \ttypealias Filter = Structure.Filter
            \ttypealias Aspect = Structure.Aspect
            \ttypealias Particle = Structure.Particle


            """
            result += "\tstatic var statics: [Filter] { ["
                + selectedFilters.sorted(by: { $0.name < $1.name })
                .map { "Statics." + $0.name.sourceCode }
                .joined(separator: ", ")
                + "] }\n\n"

            result += "\tenum Statics {"
                + selectedFilters
                .sorted(by: { $0.name < $1.name })
                .map { $0.sourceCode(tab: 3, inline: false, document: document) }
                .joined(separator: "\n") + "\n"
                + "\t}\n}\n"

            return result
        }

        // MARK: Content

        var body: some View {
            VStack(alignment: .leading) {
                Form {
                    Text(fileUrl?.path ?? "No file selected")
                        .onTapGesture {
                            importFile.toggle()
                        }
                        .fileImporter(
                            isPresented: $importFile,
                            allowedContentTypes: [.swiftSource],
                            allowsMultipleSelection: false
                        ) { result in
                            switch result {
                            case let .success(files):
                                let file = files.first!
                                let gotAccess = file.startAccessingSecurityScopedResource()
                                if !gotAccess { return }
                                analyzeFile(file)
                                file.stopAccessingSecurityScopedResource()
                            case let .failure(error):
                                // handle error
                                print(error)
                            }
                        }
                    SelectorView(data: filters, selection: $selectedFilters) { Text($0.description) }
                    Text(filtersSourceCode)
                        .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .topLeading)
                        .font(.system(size: 8))
                }
                .formStyle(.grouped)

                HStack {
                    Button("Create static filter") {
                        let filter = Structure.Filter()
                        filter.name = "Static Filter"
                        try! document.$structure.addStaticObject(item: filter)
                    }

                    Button("Export") {
                        showExportConfirmation.toggle()
                    }
                    .disabled(selectedFilters.isEmpty || fileUrl == nil)
                    .confirmationDialog("Export", isPresented: $showExportConfirmation) {
                        Button("Export") {
                            Task {
                                guard let fileUrl, fileUrl.startAccessingSecurityScopedResource() else { return }
                                try! filtersSourceCode.write(to: fileUrl, atomically: true, encoding: .utf8)
                                fileUrl.stopAccessingSecurityScopedResource()
                                selectedFilters
                                    .filter { !$0.isStatic }
                                    .forEach {
                                        do {
                                            try document.$structure.makeObjectStatic(item: $0)
                                        } catch {}
                                    }
                                showDeleteConfirmation = selectedFilters.contains(where: { !$0.isStatic })
                            }
                        }
                    }
                    .confirmationDialog("Delete", isPresented: $showDeleteConfirmation) {
                        Button("Delete") {
                            Task {
                                selectedFilters
                                    .filter { !$0.isStatic }
                                    .forEach {
                                        document.delete($0)
                                    }
                            }
                        }
                    }
                }
                .padding()
                .frame(maxWidth: .infinity, alignment: .trailing)
            }
        }

        // MARK: Functions

        func analyzeFile(_ file: URL) {
            let text = try! String(contentsOf: file, encoding: .utf8)
            let regex = /let filter = Filter\(id: "(.*)".uuid\)/
            let declarations = text.split(separator: "\n")
                .compactMap { try? regex.firstMatch(in: $0) }
                .map { String($0.1).uuid }
                .compactMap { document[Structure.Filter.self, $0] }

            guard !declarations.isEmpty else {
                // Hier wird der Text auf ein leeres File gecheckt, das dann gefüllt wird.
                var text = text
                text.removeAll(where: { $0.isWhitespace })
                if text.isEmpty {
                    fileUrl = file
                }
                return
            }
            
            selectedFilters = declarations
            fileUrl = file
        }
    }
}
